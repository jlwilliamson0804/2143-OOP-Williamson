/**
*  Course: CMPS 2143 - OOP
*  Assignment: A02
*  Purpose: Comment assignment
* 
*  @author Joseph Williamson
*  @version 1.1 09/03/18 
*/

#include <iostream>

using namespace std;

int A[100];



struct Node

{

    int x;

    Node *next;

    Node()

    {

        x = -1;

        next = NULL;

    }

    Node(int n)

    {

        x = n;

        next = NULL;

    }

};



class List

{

  private:

    Node *Head;

    Node *Tail;

    int Size;



  public:

    List()

    {

        Head = Tail = NULL;

        Size = 0;

    }


 /**
  *  Purpose is to push new entry onto the list at the end
  *
  *  @param {int} value inserted
  *  @return {void} has no return value
  */

    void Push(int val)

    {

        // allocate new memory and init node

        Node *Temp = new Node(val);



        if (!Head && !Tail)

        {

            Head = Tail = Temp;

        }

        else

        {

            Tail->next = Temp;

            Tail = Temp;

        }

        Size++;

    }


/**
  *  Purpose is to push new entry onto the list in front
  *
  *  @param {int} value inserted
  *  @return {void} has no return value
  */
    void Insert(int val)

    {

        // allocate new memory and init node

        Node *Temp = new Node(val);



        // figure out where it goes in the list



        Temp->next = Head;

        Head = Temp;

        if (!Tail)

        {

            Tail = Head;

        }

        Size++;

    }


/**
  *  Purpose is to print the tail of the list
  *
  *  @param {} no param
  *  @return {void} has no return value
  */
    void PrintTail()

    {

        cout << Tail->x << endl;

    }


/**
  *  Purpose is to print the list
  *
  *  @param {} no param
  *  @return {void} has no return value
  */
    string Print()

    {

        Node *Temp = Head;

        string list;



        while (Temp != NULL)

        {

            list += to_string(Temp->x) + "->";

            Temp = Temp->next;

        }



        return list;

    }



    // not implemented 

    int Pop()

    {

        Size--;

        return 0; //

    }

/**
  *  Purpose is to overload the "plus" operator for List
  *
  *  @param {const List} List Rhs
  *  @return {List} NewList
  */

    List operator+(const List &Rhs)

    {

        // Create a new list that will contain both when done

        List NewList;



        // Get a reference to beginning of local list

        Node *Temp = Head;



        // Loop through local list and Push values onto new list

        while (Temp != NULL)

        {

            NewList.Push(Temp->x);

            Temp = Temp->next;

        }



        // Get a reference to head of Rhs

        Temp = Rhs.Head;



        // Same as above, loop and push

        while (Temp != NULL)

        {

            NewList.Push(Temp->x);

            Temp = Temp->next;

        }



        // Return new concatenated version of lists

        return NewList;

    }




/**
  *  Purpose is to find place in List as if an array
  *
  *  @param {int} value of index
  *  @return {int} value of place in List
  */
    int operator[](int index)

    {

        Node *Temp = Head;



        if (index >= Size)

        {

            cout << "Index out of bounds, exiting";

            exit(0);

        }

        else

        {



            for (int i = 0; i < index; i++)

            {

                Temp = Temp->next;

            }

            return Temp->x;

        }

    }



    friend ostream &operator<<(ostream &os, List L)

    {

        os << L.Print();

        return os;

    }

};


//controls operation of program
int main(int argc, char **argv)

{

    List L1;

    List L2;



    for (int i = 0; i < 25; i++)

    {

        L1.Push(i);

    }



    for (int i = 50; i < 100; i++)

    {

        L2.Push(i);

    }



    //cout << L1 << endl;

    L1.PrintTail();

    L2.PrintTail();



    List L3 = L1 + L2;

    cout << L3 << endl;



    cout << L3[5] << endl;

    return 0;

}
